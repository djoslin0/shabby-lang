#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdarg.h>
#include "file.h"
#include "bytecode.h"

  ///////////////////
 // file pointers //
///////////////////

static FILE *gen_ptr = NULL; // generated bytecode
static FILE *bin_ptr = NULL; // binary output

  ////////////////////
 // label tracking //
////////////////////

#define MAX_LABELS 128

struct {
    uint16_t label;
    uint16_t offset;
} typedef label_s;
static label_s labels[MAX_LABELS] = { 0 };
static uint8_t on_label = 0;

static void label_remember(uint16_t label, uint16_t offset) {
    assert(on_label < MAX_LABELS);
    labels[on_label].label = label;
    labels[on_label].offset = offset;
    printf("remembering label: %04X -> %04X\n", label, offset);
    on_label++;
}

static label_s* label_get(uint16_t label) {
    for (uint16_t i = 0; i < on_label; i++) {
        if (labels[i].label == label) {
            printf("retrieved label: %04X -> %04X\n", label, labels[i].offset);
            return &labels[i];
        }
    }
    printf("could not find label: %04X!\n", label);
    return NULL;
}

  /////////////////////
 // jump resolution //
/////////////////////

void jump_resolution(FILE* gen_ptr_arg, FILE* bin_ptr_arg) {
    gen_ptr = gen_ptr_arg;
    bin_ptr = bin_ptr_arg;

    // output gen to bin while stripping and remembering labels
    int bail = 0;
    while(++bail < 1000) {
        bytecode_t type = fgetc(gen_ptr);

        // exit at EOF
        if (type == (bytecode_t)EOF) { break; }

        // remember labels
        if (type == BC_LABEL) {
            label_remember(fget16(gen_ptr), ftell(bin_ptr));
            continue;
        }

        // copy type to bin
        fputc(type, bin_ptr);

        // copy params to bin
        uint16_t copy_amount = bytecode[type].params * bytecode[type].param_size;
        while (copy_amount-- > 0) { fputc(fgetc(gen_ptr), bin_ptr); }
    }
    assert(bail < 1000);

    // replace ijump values with label values
    bail = 0;
    fseek(bin_ptr, 0, 0);
    while(++bail < 1000) {
        bytecode_t type = fgetc(bin_ptr);

        // exit at EOF
        if (type == (bytecode_t)EOF) { break; }

        // remember labels
        if (type == BC_IJUMP) {
            uint16_t ijump_param = ftell(bin_ptr);
            label_s* label = label_get(fget16(bin_ptr));
            assert(label != NULL);
            fseek(bin_ptr, ijump_param, 0);
            fput16(label->offset, bin_ptr);
            continue;
        }

        // skip over params
        uint16_t skip_amount = bytecode[type].params * bytecode[type].param_size;
        fseek(bin_ptr, skip_amount, SEEK_CUR);
    }
    assert(bail < 1000);
}

  //////////
 // main //
//////////

int main(int argc, char *argv[]) {
    assert(argc == 2);

    char gen_buffer[128] = { 0 };
    sprintf(gen_buffer, "../bin/%s.gen", argv[1]);
    gen_ptr = fopen(gen_buffer, "rb");

    char bin_buffer[128] = { 0 };
    sprintf(bin_buffer, "../bin/%s.bin", argv[1]);
    bin_ptr = fopen(bin_buffer, "wb+");

    jump_resolution(gen_ptr, bin_ptr);

    fclose(gen_ptr);
    fclose(bin_ptr);

    return 0;
}
